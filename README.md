# It's HolyKim's Algorithm Learning Record Using Python

## Introduction
Welcome to my Personal Algorithm Learning Record! This repository serves as a central hub for all my exercises and projects related to algorithm practice in Python. My goal is to improve my problem-solving skills and deepen my understanding of various algorithm concepts through consistent practice and documentation.

## Objectives
- **Skill Enhancement:** Improve coding skills by solving diverse algorithm challenges.
- **Conceptual Understanding:** Deepen understanding of algorithms and data structures.
- **Documentation:** Keep a detailed record of learning progress and solutions for future reference.

## Algorithm Techniques covered in this repository

  ### Brute Force
  - **Brute force algorithms solve problems through exhaustive search, trying every possible option to find the solution. They are straightforward but can be inefficient for large datasets.**
  
  ### DFS-BFS (Depth-First Search and Breadth-First Search)
  - **DFS and BFS are algorithms for traversing or searching tree or graph data structures. DFS explores as far along a branch as possible before backtracking, while BFS explores all neighbors at the present depth prior to moving on to nodes at the next depth level.**
  
  ### Greedy
  - **Greedy algorithms build up a solution piece by piece, always choosing the next piece that offers the most immediate benefit. They are used for optimization problems but do not always lead to the optimal global solution.**
  
  ### Stack and Queue
  - **These data structures are fundamental in many algorithms, dictating the order of processing. Stacks follow the Last In First Out (LIFO) principle, and queues follow the First In First Out (FIFO) principle. They are often used in parsing, scheduling tasks, and caching.**
  
  ### Binary Search
  - **Binary search is used to find the position of a target value within a sorted array. The algorithm compares the target value to the middle element of the array; if they are not equal, the half in which the target cannot lie is eliminated, cutting the search space in half.**
  
  ### Dynamic Programming
  - **Dynamic programming is used to solve complex problems by breaking them down into simpler subproblems. It is applicable where the problem can be divided into overlapping sub-problems that can be solved independently.**
  
  ### Graph
  - **Graph algorithms are used to compute properties of graphs or networks, such as finding the shortest path, detecting cycles, or determining connectivity. They are crucial in network routing, molecular structure analysis, and social network analysis.**
  
  ### Implementation
  - **This involves converting the algorithms and their concepts into working, efficient code based on problem requirements. This category often includes simulating the problem scenario and handling input/output operations.**
  
  ### Using Map and Set
  - **Maps (dictionaries in Python) and sets are data structures that allow for efficient data retrieval and manipulation. Algorithms using these structures often leverage unique elements (sets) or key-value pairs (maps) to solve problems involving counting, item organization, or fast lookups.**


## Explanation of terms used in each file
- **/comment(#):** Explanation of the rationale and guidelines for writing each piece of code
- **/difficulty(D1 or D2 or D3):** Indicators of the difficulty level for each problem
- **/attempts(T1 or T2 or ...):** Indicator of the number of attempts before success

## Contact
If you have any questions or would like to connect, please feel free to [create an issue](https://github.com/ssKimholy) on this profile or reach out through my social media channels linked below.

